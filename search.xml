<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[插入排序]]></title>
      <url>//niuapp.github.io/2016/12/11/3_Java_Sort/</url>
      <content type="html"><![CDATA[<p>关键字：插入排序 排序</p>
<a id="more"></a> 
<p><br>   </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br></p>
<blockquote>
<p>插入排序，记住一点就好 <strong>目标位置往前的部分 要保持有序，目标要插入到该部分对应位置</strong></p>
</blockquote>
<p>先上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//定义数组</span></div><div class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>,<span class="number">1</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//遍历数组</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//查找 a[i] 在 i 索引之前 的排序后位置</span></div><div class="line">		<span class="comment">//当前一个元素大于后一个元素时，交换两个元素，</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;=<span class="number">1</span> &amp;&amp; a[j-<span class="number">1</span>]&gt;a[j]; j--)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> temp = a[j];</div><div class="line">		a[j] = a[j-<span class="number">1</span>];</div><div class="line">		a[j-<span class="number">1</span>] = temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(Arrays.toString(a));</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>从第二个元素开始遍历</p>
</blockquote>
<p>刚开始第一个元素是不需要管的，第一个只要一个元素，相对就是有序的，从第二个开始遍历，目的是要和第一个元素组成一个相对有序的部分，然后继续去看第三个元素，第三个要和前两个组成相对有序的部分，直到最后一个插入完成，排序结束。</p>
<p><br></p>
<blockquote>
<p>内层循环</p>
</blockquote>
<p>上边说了，需要把元素插入到前边相对有序的部分之中，所以要从当前位置往前遍历(<code>--</code>)，比较当前元素和前一个元素，如果当前元素<strong>小</strong>，就交换位置继续往前比较，如果当前元素<strong>大</strong>，那么就和前边部分组成相对有序，就跳出循环继续插入下一个元素</p>
<blockquote>
<p>效率</p>
</blockquote>
<p>它比较适合使用在已经<strong>基本有序</strong>的数组，比如<code>[1, 3, 4, 2, 6, 9, 7]</code>，像这个数组，已经基本有序了，它在使用插入排序时效率就很高了， 不需要老是去遍历相对很多个元素了。</p>
<blockquote>
<p>插入排序非常容易理解，所以要手写代码的话也比较流畅，记录一下。</p>
</blockquote>
<p><br><br><em>完</em><br><br></p>
<blockquote>
<p>总结:<br>之前买的<em>巴克球</em>今天到了，更新个简单的，代码少，面试如果要手写个排序可以用到。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android中的Handler消息处理机制]]></title>
      <url>//niuapp.github.io/2016/12/10/2_Android_Handler/</url>
      <content type="html"><![CDATA[<p><img src="/assets/img/cover/handler.jpg" alt="Handler消息处理机制"></p>
<p>关键字：Handler Looper 多线程<br><a id="more"></a><br>封面图出自黑马的一位老师<br><br>   </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br></p>
<blockquote>
<p>Handler的消息处理机制是为了解决Android多个线程操作UI带来的混乱和卡顿(看上去它确实是为此而存在的)</p>
</blockquote>
<p>为什么这么说呢？虽然现在Android会禁止非主线程去更新UI，但是为什么要这样？</p>
<p>不从代码来看，试想一哈，学校的食堂窗口，如果学生们一起去挤去抢，那样会有多混乱，超低的效率，超随机的处理方式，可能有人等好久都吃不上饭了。</p>
<p>排队打饭，按顺序来就可以避免这种乱七八糟不可控制的情况。</p>
<p>这个就是规则的好处，而Android也是这样，为了避免多个线程去抢着更新UI，就直接规定非主线程不能更新UI，接着放出一个规则，非主线程要通过Handler来排队更新UI。</p>
<p><br><br><strong>总结一下：</strong>Android中的Handler消息处理机制，就类似排队打饭，只不过不是自己去排队了，而且变成了电话预约，打电话先排上队，然后等通知。就是这样，而放到代码中，这个排队的人就是叫 “Handler”，打出去的排队电话就是 “Message”，排队通道就是 “MessageQueue”, 食堂大妈就是 “Looper”。</p>
<blockquote>
<p>额，写完才发现，好像去医院挂号更加像这个，但鉴于敲代码的身体都很好，基本不去医院，那就打饭的例子好了。</p>
</blockquote>
<p><br></p>
<h2 id="简略流程"><a href="#简略流程" class="headerlink" title="简略流程"></a>简略流程</h2><p><br></p>
<p>从以上图片和例子，先大体过一下简略的流程，然后再走较详细的。</p>
<p>一般在使用Handler发送处理消息的时候，就是通过Handler对象发送一个消息，然后它重写消息处理的方法，处理消息。</p>
<p>其实知道这些已经够了，内部的具体实现在用的时候一般是不用关心的，但它的想法是真的很好，通过规则避免问题，咱可以学习瞻仰下大神的想法。</p>
<blockquote>
<p>重点来了，首先Handler对象调用<strong>发消息</strong>的方法(具体先不管)，接着消息跑到了消息<strong>队列</strong> MessageQueue，然后通过Looper不停的轮询，取出消息队列中的消息<strong>丢还</strong>给<strong>发消息的Handler</strong>去处理，Handler通过一些判断，使用<strong>对应的方法</strong>处理消息。</p>
</blockquote>
<p>其实就是这样一个大概的流程，结合上边的例子可以看出这样做的好处，各个线程的需要呈现在用户眼前的任务不再混乱甚至卡顿，而是变成了单线处理方式，有规律有规则。就用这样一个简单的流程去解决，再次佩服！</p>
<p><br></p>
<h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p><br></p>
<p>这里从创建Handler Looper MessageQueue开始，然后在较详细的走一圈发送消息的过程。</p>
<p><br></p>
<h3 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><ol>
<li>使用Handler时，是由我们自己new出的Handler对象。</li>
<li>在Handler的构造方法中，会有<code>mLooper = Looper.myLooper();</code>,这里会得到Looper。而这个方法中是通过<code>(Looper)sThreadLocal.get();</code>得到的Looper，是从当前线程获取的，然后去找<code>sThreadLocal</code>，发现是<code>Looper</code>类中的静态成员，而且是在加载时就已经初始化，返回去再看<code>(Looper)sThreadLocal.get();</code>，既然是<code>get()</code>得到的，那应该是有个<code>set()</code>或者类似的方法，继续找，发现它的<code>set()</code>方法，然后里边直接就<code>new Looper()；</code>。</li>
<li>在Looper的构造方法中，MessageQueue初始化<code>mQueue = new MessageQueue()</code>。</li>
</ol>
<p>由上可以看出，Handler是自己初始化的，而Looper和MessageQueue都是已经创建好的。</p>
<blockquote>
<p>应用启动时，主线程启动，<code>ActivityThread</code>中的<code>main()</code>方法执行，接着 <code>Looper.prepareMainLooper()</code>被调用，然后调用<code>prepare()</code>，调用了<code>上边2</code>那里那个<code>set()</code>，初试化了Looper和MessageQueue，在这之后，会在<code>main()</code>中继续调用<code>Looper.loop()</code>，去直接开始<strong>轮询</strong>MessageQueue中的消息，在这里，它会取出消息<code>Message msg = queue.next(); // might block</code>(可能会阻塞，后边再说)<br>，取出之后再解析分发消息，<strong>消息由哪个Handler来的，就把消息给它分发处理</strong><code>msg.target.dispatchMessage(msg);</code>,这里这个<code>target</code>来自Message对象的<code>target</code>属性，用于记录是哪个Handler所属的消息。</p>
</blockquote>
<p><br></p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><ol>
<li>调用Handler的<code>obtain()</code>，得到Message对象。</li>
<li>设置消息内容。</li>
<li>调用Handler的<code>sendMessage()</code>发送消息，经过<code>sendMessageDelayed()</code>到<code>sendMessageAtTime()</code>，在这里，MessageQueue的对象给这个消息排上队<code>queue.enqueueMessage(msg, uptimeMillis)</code>,给Message的对象target赋值<code>msg.target = this</code> 使 target代表当前的 Handler对象。</li>
<li><p><code>enqueueMessage()</code>中，通过<code>when</code>(上边的”uptimeMillis”指的是消息的时间)把消息放到相应的位置(消息队列是一个单链表)。接着<code>if (needWake) {nativeWake(mPtr);}</code>(一个进程间通信机制：管道（pipe）。主线程Looper从消息队列读取消息，当读完所有消息时，进入睡眠，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据。)保证轮询状态，接着<code>loop()</code>中调用Message<br>的target(发送消息的Handler对象)的<code>dispatchMessage()</code>，让发出这个消息的Handler去分发消息处理。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">	handleCallback(msg);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	handleMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 判断 msg是否设置了callback(Runnable对象，在得到msg时设置，重写run()方法)。</p>
<p> 设置了 就调用handleCallback()调用run方法。</p>
<p> 没有设置 就判断 当前Handler是否设置了mCallback(Callback对象，在创建Handler时设置，重写handlerMessage方法，常用).</p>
<p> 设置了就调用这个对象的 handlerMessage方法</p>
<p> 都没有 就调用 Handler 类的 handlerMessage方法。</p>
</li>
<li><p>处理完继续轮询。</p>
</li>
</ol>
<p><br><br><em>完</em><br><br></p>
<blockquote>
<p>总结:<br>多么厉害的想法，简单有效的规程处理规避了多线程带来的问题，强无敌！作为一个渣渣，表示一下对大神的膜拜！ <strong>b(￣▽￣)d</strong></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的网络编程初试]]></title>
      <url>//niuapp.github.io/2016/12/09/1_Java_Socket/</url>
      <content type="html"><![CDATA[<p><img src="/assets/img/cover/网络编程.png" alt="网络编程"></p>
<p>关键字：TCP UDP Socket 网络编程<br><a id="more"></a><br><br>   </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br></p>
<blockquote>
<p>网络编程：编写通过网络建立联系的程序</p>
</blockquote>
<p>可以分析这个”网络编程”</p>
<p>要建立连接必然就是2个或以上的个体，可以先把每一个个体当做一个叫”Socket”的对象。</p>
<p>如果它们之间想建立联系，其中一个Socket就需要知道另一方在哪儿，所以每个Socket得有个位置属性，在计算机中，”ip”确定网络上的位置，”端口号”确定程序在计算机中的位置，这个属性分解成”ip”和”端口号”来确定。</p>
<p>接着两个Socket要开始互相交流了，需要一个交流规则，这个规则就是”协议”。</p>
<p><br><br><strong>总结一下：</strong>网络编程，就是两个可以通过ip和端口号确定位置的Socket使用相同的协议来进行交流。</p>
<blockquote>
<p>网络通信三要素: <strong>ip  -  端口号  -  协议</strong></p>
</blockquote>
<p>“ip”和”端口号”，这两个暂且略过不提，这里只需要知道一个指网络中的位置，一个指计算机中的位置就好。</p>
<blockquote>
<p>插入一句，我自己现在的理解，面向对象的开发，就是创造对象，梳理对象之间的关系，要注重无中生有和拿来主义，只是在必要的时候去进行比较接近底层的实现(关键现在也没那个能力啊，努力中…)，所以先重点放到分析对象和关系，构造对象和关系上。</p>
</blockquote>
<p>协议，在这里分两部分用java代码实现UDP和TCP协议支持的小小程序，而它们所支持的应用层协议可以之后去稍微了解下。</p>
<p>分析：</p>
<ol>
<li>因为要两个或以上的人来建立连接，所以需要创建出两个或以上的这个对象，一个发送，一个接收</li>
<li>这两个对象需要有位置标识，需要确定</li>
<li>这两个对象需要一个协议来传输数据</li>
</ol>
<p><br></p>
<h2 id="基于UDP协议的”DatagramSocket”"><a href="#基于UDP协议的”DatagramSocket”" class="headerlink" title="基于UDP协议的”DatagramSocket”"></a>基于UDP协议的”DatagramSocket”</h2><p><br></p>
<p>UDP协议是面向无连接的，可以把它当做广播、通知来看，一方发给另一方就是 把消息直接丢给它，不管对方收没收到，我发了就好了，所以发送端和接收端都是比较简单的，它们没有建立起连接(不指联系)，就单是通过ip端口号确定目标，发送 接收。</p>
<p>UDP一个使用最多的地方就是网络聊天了。接收端接收消息，发送端发送消息，当然实际中的聊天工具肯定不是这么简单，中间要经过一个服务器去转发处理什么的，但这个是基础，通过这个明白一些原理还是不错的。</p>
<p>Java中通过 “DatagramSocket” 来创建基于UDP的Socket对象，而Socket中又有了ip和端口号属性。</p>
<p>这一个玩意儿就把 ip、端口号、协议都确定了，所以就拿来这个直接使用就好了。</p>
<blockquote>
<p>好了，开始写代码。</p>
</blockquote>
<p><br></p>
<h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><p>当然是先去 看api，查这个类的构造方法。</p>
<p>发现这个它有构造方法能直接确定端口号，然后还有一个有 “InetAddress<br>“参数，查发现，这个表示ip，如果使用这个构造就直接确定了自己Socket的端口号和ip，但这里有个问题，现在是想发送给另一个Socket，所以使用这个构造和对方位置是没什么关系的，所以继续查api，找有没有什么发送的方法</p>
<p>果然，有个<code>void send(DatagramPacket p)</code>这个方法，但它需要一个参数，看名字这应该是一个数据包，发送一个数据包，对就是这样，所以继续看这个类是怎么回事。</p>
<p>看构造方法，这里也有可以设置端口号和ip的位置，这下就可以确定发送目标了，然后还有byte数组，这肯定是要发送的数据了。</p>
<p>走完一圈，从创建 DatagramSocket对象，然后到它发送数据，整个流程就是这样了，所以代码就有了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">String msg = <span class="string">"hello!!"</span>; <span class="comment">//消息内容</span></div><div class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(); <span class="comment">//发送端Socket对象</span></div><div class="line">ds.send(<span class="keyword">new</span> DatagramPacket(msg.getBytes(), msg.getBytes().length, InetAddress.getByName(<span class="string">"192.168.0.66"</span>), <span class="number">16666</span>)); <span class="comment">//发送给 192.168.0.66：16666</span></div></pre></td></tr></table></figure>
<p>超级简单的一个发送端就写好了，当然，这里只是把主体过一次，最后会有一个小demo来总结下。</p>
<p><br></p>
<h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><p>继续看 DatagramSocket类的方法，有一个接收的方法 <code>void receive(DatagramPacket p)</code>,同样需要一个数据包参数，这里这个参数不是其他地方传过来的，如果是自己创建肯定是没有数据的，因为还没接收到啊，所以这里应该是一个用来接收数据的空包，什么是空的包，构造数据包的参数，恩，是个空的byte数组就好了。</p>
<p>问题来了，这个byte数组要多大呢，肯定是越大越好，要不数据接收不全咋办，可是这个大没有极限啊，而且还占地方，所以只能是尽量大了，这可以根据实际情况决定，比如这边我知道只是接收一个短字符串，我弄个byte[100]就不少了，具体情况具体看待，一般可以byte[1024]，UDP面向无连接，所以丢包也就很正常了，毕竟快哈。</p>
<p>还有一个问题，接收的参数不是传过来的，而是你创建的空包，所以什么时候接收呢，怎么就知道人家发送了？…实际上答案就是”不知道”。人家又没通知你，哪里知道要开始接收啊。所以这个接收端还要保持长时间开着，不停得保持接收状态，就好像人的耳朵一样，接收广播通知，这也是UDP的特点了，所以可以来一个死循环，保持这个接收端一直开着。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">16666</span>);<span class="comment">//确定端口号，ip计算机会帮你确定</span></div><div class="line"></div><div class="line"><span class="comment">//用循环无限接收</span></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//接收包</span></div><div class="line">	<span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">	DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</div><div class="line">	</div><div class="line">	<span class="comment">//接收</span></div><div class="line">	ds.receive(dp);</div><div class="line">	<span class="comment">//解析为字符串</span></div><div class="line">	String ss = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</div><div class="line"></div><div class="line">	<span class="comment">//获取发送者ip 和主机名</span></div><div class="line">	String name = dp.getAddress().getHostName();</div><div class="line">	String ip = dp.getAddress().getHostAddress();</div><div class="line"></div><div class="line">	System.out.println(name+<span class="string">" "</span>+ip+<span class="string">" : "</span>+ss);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个超级简单的接收端就好了</p>
<p><br></p>
<blockquote>
<p>UDP小demo<br>接下来是一个完整的demo，可以放到一个 .java文件中编译运行下试试，包含了发送端 接收端，当然也可以分开写</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.net.DatagramSocket;</div><div class="line"><span class="keyword">import</span> java.net.DatagramPacket;</div><div class="line"><span class="keyword">import</span> java.net.InetAddress;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"></div><div class="line"><span class="comment">//发送端</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendT</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;	</div><div class="line">	<span class="keyword">private</span> DatagramSocket ds;</div><div class="line">	</div><div class="line">	<span class="comment">//通过测试类传过来的DatagramSocket对象进行初始化</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SendT</span><span class="params">(DatagramSocket ds)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">this</span>.ds = ds;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			<span class="comment">//封装键盘录入</span></div><div class="line">			BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">			String line = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">			</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="comment">//System.out.print("我说：");</span></div><div class="line">				line = br.readLine();</div><div class="line">				</div><div class="line">				<span class="keyword">if</span> (line.equals(<span class="string">"null"</span>))</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//把录入的数据打包</span></div><div class="line">				<span class="keyword">byte</span>[] bys = line.getBytes();</div><div class="line">				DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length, InetAddress.getByName(<span class="string">"192.168.22.68"</span>), <span class="number">19999</span>);</div><div class="line"></div><div class="line">				<span class="comment">//发送</span></div><div class="line">				ds.send(dp);</div><div class="line">			&#125;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException e)</div><div class="line">		&#123;</div><div class="line">			System.out.println(<span class="string">"---------"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">try</span></div><div class="line">			&#123;</div><div class="line">				<span class="comment">//关闭流</span></div><div class="line">				ds.close();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (Exception e)</div><div class="line">			&#123;</div><div class="line">			&#125;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//接收端</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveT</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span> DatagramSocket ds;</div><div class="line">	</div><div class="line">	<span class="comment">//通过测试类传过来的DatagramSocket对象进行初始化</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReceiveT</span><span class="params">(DatagramSocket ds)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">this</span>.ds = ds;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>)<span class="comment">//一直等待接收</span></div><div class="line">			&#123;</div><div class="line">				<span class="comment">//缓存包</span></div><div class="line">				<span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</div><div class="line">				DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</div><div class="line"></div><div class="line">				<span class="comment">//接收</span></div><div class="line">				ds.receive(dp);</div><div class="line"></div><div class="line">				<span class="comment">//转成字符串</span></div><div class="line">				String s = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</div><div class="line"></div><div class="line">				String name = dp.getAddress().getHostName();</div><div class="line">				String ip = dp.getAddress().getHostAddress();</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"---------------"</span>);</div><div class="line">				System.out.println(name+<span class="string">"-&gt; "</span>+s);</div><div class="line">				System.out.println(<span class="string">"---------------"</span>);</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException e)</div><div class="line">		&#123;</div><div class="line">			System.out.println(<span class="string">"---------"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//不关闭流</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试主类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">//创建发送端和接收端对象</span></div><div class="line">		SendT st = <span class="keyword">new</span> SendT(<span class="keyword">new</span> DatagramSocket());</div><div class="line">		ReceiveT rt = <span class="keyword">new</span> ReceiveT(<span class="keyword">new</span> DatagramSocket(<span class="number">19999</span>));</div><div class="line"></div><div class="line">		<span class="comment">//开启线程</span></div><div class="line">		<span class="keyword">new</span> Thread(rt).start();</div><div class="line">		<span class="keyword">new</span> Thread(st).start();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="基于TCP协议的”Socket”和”ServerSocket”"><a href="#基于TCP协议的”Socket”和”ServerSocket”" class="headerlink" title="基于TCP协议的”Socket”和”ServerSocket”"></a>基于TCP协议的”Socket”和”ServerSocket”</h2><p><br></p>
<p>TCP协议是面向连接的，所以和UDP协议最大的不同就是在于，它需要保持一个长连接，通过这个连接通道来进行联系。这个看起来就很繁琐，所以一般可以用来传输文件什么的，做一些比较耗时的事。比起UDP就可靠多了。</p>
<p>Java中用”Socket”和”ServerSocket”两个类来建立基于TCP协议的联系。</p>
<p>虽然看起来比UDP复杂，但Java代码实现却简单多了，它内部已经做好了很多事，所以只需要有一个通过连接通道进行传输的概念就好了。</p>
<p><br></p>
<h3 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h3><p>Socket类的对象。</p>
<p>查api，看构造方法，可以直接new出来 或者设置一些参数，因为要保持长连接，通过连接通道交流，发送端要和服务端先建立连接通道，所以需要选择带端口号和ip的构造来创建对象，在构造时java就会帮忙去和指定的ip端口建立连接。</p>
<p>在构造完后，其实两端已经建立好了连接通道(java都帮搞定了)，所以就可以开始通过通道发送数据了，看api有一个<code>OutputStream getOutputStream()</code>方法，这下就好了，IO操作，写入数据，关闭流完事，下边代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//客户端Socket对象</span></div><div class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">"192.168.22.66"</span>, <span class="number">16666</span>);</div><div class="line"></div><div class="line"><span class="comment">//获取输出流</span></div><div class="line">OutputStream os = s.getOutputStream();</div><div class="line"></div><div class="line"><span class="comment">//写入数据</span></div><div class="line">os.write(<span class="string">"AAAAA"</span>.getBytes());</div><div class="line"></div><div class="line"><span class="comment">//关闭流</span></div><div class="line">s.close();</div></pre></td></tr></table></figure>
<p>非常简单，一个发送端就好了，TCP中发送端和接收端是可以互相通信的，所以在上服务端的反馈的话，一个简单的客户端就能搞定了，继续看接收端</p>
<p><br></p>
<h3 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h3><p>ServerSocket对象。</p>
<p>同样的看api，也和UDP一样，创建当然需要一个端口号来确定位置。</p>
<p>创建之后，想接收到发送端的消息，看api发现没什么对应的方法来直接获取消息，但有一个返回Socket对象的方法。看方法名，接收，那就是了，这个方法就是拿到 连接到这个接收端的代表发送端的Socket。</p>
<p>有了Socket之后，一切就又很简单了，Socket中除了获取输出流，还有获取输入流的方法<code>InputStream getInputStream()</code>，那个这个就是对应发送端的输出流了，读这个流就可以获取发送信息了。</p>
<p>接收端也是可以去给发送端发消息的，所以其实接收端可以当做一个小小的服务器，发送端就是一个要和这个服务器连接的客户端了。它们之间是可以互相通信的。</p>
<p>简单代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">16666</span>);</div><div class="line"></div><div class="line"><span class="comment">//监听</span></div><div class="line">Socket s = ss.accept();</div><div class="line"></div><div class="line"><span class="comment">//获取输入流</span></div><div class="line">InputStream is = s.getInputStream();</div><div class="line"></div><div class="line"><span class="comment">//读数据</span></div><div class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> ((l=is.read(bys)) != -<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">	System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, l));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//不关，保持服务 或者调用 close()关闭服务</span></div></pre></td></tr></table></figure>
<p>TCP的demo就没了，如果只是简单的发送接收上边的两小段就可以了，但它可不是为了聊天存在的，应该当做客户端和服务端，用来传输文件，这样其实关于Socket的代码也大体是这些(多了停止输入或输出两个方法，查api)，只不过多了一些IO的代码，那些都比较固定，练java的IO操作可以试着写写。</p>
<p><br><br><em>完</em><br><br></p>
<blockquote>
<p>总结:<br>java做了绝大部分事情，只是把可能需要变动的给暴露出来，所以也就没有关于怎么实现的描述了(其实我是不太懂)，但基本过程还是可以稍微看下的，可当做回顾复习之类，第一次就写这么多，竟然花了4个小时，还是很有成就感的，哈哈。</p>
</blockquote>
<p><br><br>在csdn上看到一句话：</p>
<blockquote>
<p><strong>代码是最为耐心、最能忍耐和最令人愉快的伙伴，在任何艰难困苦的时刻，它都不会抛弃你。</strong></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[总有一个开始]]></title>
      <url>//niuapp.github.io/2016/11/29/start/</url>
      <content type="html"><![CDATA[<p>—— 关于源头</p>
<a id="more"></a>
<h3 id="找工作难"><a href="#找工作难" class="headerlink" title="找工作难"></a>找工作难</h3><p>现在才发现，找工作原来这么难。</p>
<p>作为一个学历只到大专，而且非计算机类专业，感觉现在好苦逼，我再一次为自以为是付出了代价。</p>
<p>至此，我不得不为接下来能找到工作而准备，所以有了这个准备开始的牢骚。</p>
<h3 id="Android应用开发"><a href="#Android应用开发" class="headerlink" title="Android应用开发"></a>Android应用开发</h3><p>Android应用开发，我现在相对擅长的就是这个了。</p>
<p>相对于其他方向的前端来说，Android开发还是比较容易上手的，只需要会一些Java基础和几个Android的知识点，这样就可以上手开发一个Android应用了，我指比较简单的。</p>
<p>所以一个Android应用开发人员有一个虔诚爱分享的心，有一个爱学习的脑子，有一个好身体就可以了</p>
<p>当然，现在安卓开发门槛越来越低，所以要表现的比别人强大，需要具备探究的精神，这很重要。</p>
<h3 id="好了，重振精神，开始吧"><a href="#好了，重振精神，开始吧" class="headerlink" title="好了，重振精神，开始吧"></a>好了，重振精神，开始吧</h3>]]></content>
    </entry>
    
  
  
</search>
